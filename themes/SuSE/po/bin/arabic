#! /usr/bin/perl

use Encode;
use Getopt::Long;

sub is_arabic;
sub read_map;

$opt_verbose = 0;

GetOptions(
  'verbose|v' => \$opt_verbose
);


push @c, 0;

while(<>) {
  push @c, unpack("V*", encode("utf32le", decode("utf8", $_)));
}

push @c, 0;

read_map;

# isolated: 0, initial: 1, final: 2, medial: 3
for ($i = 1; $i < @c - 1; $i++) {
  next if !is_arabic $c[$i];
  $attr[$i-1] += 2 if is_arabic $c[$i-1];
  $attr[$i-1] += 1 if is_arabic $c[$i+1];
}

shift @c;
pop @c;

@attr_name = ( "isolated", "initial", "final", "medial" );

for ($i = 0; $i < @c; $i++) {
  $m = $c[$i];
  if(is_arabic $c[$i]) {
    $m = $map->{$c[$i]}{$attr_name[$attr[$i]]};
    if(!$m && $attr[$i] == 3) {		# medial -> final
      $attr[$i] = 2;
      $m = $map->{$c[$i]}{$attr_name[$attr[$i]]};
      if($m && $i < @c - 1) {
        if($attr[$i+1] == 3) {		# next char: medial -> initial
          $attr[$i+1] = 1;
        }
        elsif($attr[$i+1] == 1) {	# next char: initial ->isolated
          $attr[$i+1] = 0;
        }
      }
    }
    $m = $c[$i] unless $m;
  }
  push @m, $m;

  printf STDERR "%04x -> %04x (%s)\n", $c[$i], $m, $attr_name[$attr[$i]] if $opt_verbose;
}


print encode("utf8", decode("utf32le", pack("V*", @m)));

sub is_arabic
{
  return $_[0] >= 0x600 && $_[0] <= 0x6ff ? 1 : 0
}


sub read_map
{
  open F, "bin/arabic.txt";
  while(<F>) {
    @i = split /;/;
    $u = hex $i[0];
    if($i[5] =~ /^<(isolated|initial|final|medial)> (\S{4})$/) {
      $m = hex $2;
      if($map->{$m}{$1}) {
        printf STDERR "%04x already has a '$1' form: %04x\n", $map->{$m}{$1}
      }
      $map->{$m}{$1} = $u;
      # printf "%04x %s %04x\n", $u, $1, $m;
    }
  }
  close F;
}


